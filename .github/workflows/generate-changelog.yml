name: Generate CHANGELOG

on:
  push:
    branches:
      - main
    tags:
      - 'v*'
  workflow_dispatch:

jobs:
  changelog:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0 # Necesario para obtener todo el historial

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Generate CHANGELOG
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            
            // Obtener commits desde el √∫ltimo tag
            const { data: tags } = await github.rest.repos.listTags({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 1
            });

            const since = tags.length > 0 ? tags[0].commit.sha : '';
            
            const { data: commits } = await github.rest.repos.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              since: since ? new Date(tags[0].commit.committer.date).toISOString() : undefined,
              per_page: 100
            });

            // Clasificar commits por tipo
            const features = [];
            const fixes = [];
            const docs = [];
            const refactors = [];
            const tests = [];
            const chores = [];
            const others = [];

            for (const commit of commits) {
              const msg = commit.commit.message;
              const firstLine = msg.split('\n')[0];
              
              if (firstLine.startsWith('feat:') || firstLine.startsWith('feature:')) {
                features.push({ sha: commit.sha.substring(0, 7), message: firstLine });
              } else if (firstLine.startsWith('fix:')) {
                fixes.push({ sha: commit.sha.substring(0, 7), message: firstLine });
              } else if (firstLine.startsWith('docs:')) {
                docs.push({ sha: commit.sha.substring(0, 7), message: firstLine });
              } else if (firstLine.startsWith('refactor:')) {
                refactors.push({ sha: commit.sha.substring(0, 7), message: firstLine });
              } else if (firstLine.startsWith('test:')) {
                tests.push({ sha: commit.sha.substring(0, 7), message: firstLine });
              } else if (firstLine.startsWith('chore:')) {
                chores.push({ sha: commit.sha.substring(0, 7), message: firstLine });
              } else {
                others.push({ sha: commit.sha.substring(0, 7), message: firstLine });
              }
            }

            // Generar contenido del CHANGELOG
            let changelog = `# CHANGELOG\n\n`;
            changelog += `## [Unreleased] - ${new Date().toISOString().split('T')[0]}\n\n`;

            if (features.length > 0) {
              changelog += `### ‚ú® Features / Nuevas Funcionalidades\n\n`;
              features.forEach(c => changelog += `- ${c.message} (${c.sha})\n`);
              changelog += '\n';
            }

            if (fixes.length > 0) {
              changelog += `### üêõ Bug Fixes / Correcciones\n\n`;
              fixes.forEach(c => changelog += `- ${c.message} (${c.sha})\n`);
              changelog += '\n';
            }

            if (docs.length > 0) {
              changelog += `### üìù Documentation / Documentaci√≥n\n\n`;
              docs.forEach(c => changelog += `- ${c.message} (${c.sha})\n`);
              changelog += '\n';
            }

            if (refactors.length > 0) {
              changelog += `### ‚ôªÔ∏è Refactoring / Refactorizaci√≥n\n\n`;
              refactors.forEach(c => changelog += `- ${c.message} (${c.sha})\n`);
              changelog += '\n';
            }

            if (tests.length > 0) {
              changelog += `### üß™ Tests / Pruebas\n\n`;
              tests.forEach(c => changelog += `- ${c.message} (${c.sha})\n`);
              changelog += '\n';
            }

            // Leer CHANGELOG existente si existe
            let existingChangelog = '';
            try {
              existingChangelog = fs.readFileSync('CHANGELOG.md', 'utf8');
              // Quitar el header y agregar despu√©s del nuevo contenido
              existingChangelog = existingChangelog.replace(/^# CHANGELOG\n\n/, '');
            } catch (error) {
              console.log('No existe CHANGELOG.md, creando nuevo');
            }

            // Combinar nuevo y existente
            changelog += existingChangelog;

            // Escribir archivo
            fs.writeFileSync('CHANGELOG.md', changelog);
            console.log('‚úÖ CHANGELOG.md actualizado');

      - name: Commit CHANGELOG
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add CHANGELOG.md
          git diff --staged --quiet || git commit -m "docs: actualiza CHANGELOG autom√°ticamente

[skip ci]"
          git push

      - name: Registrar en MCP
        run: |
          curl -X POST http://localhost:5050/events \
            -H 'Content-Type: application/json' \
            -d '{
              "type": "changelog-updated",
              "payload": {
                "branch": "${{ github.ref }}",
                "commits_count": "${{ github.event.commits.length }}"
              }
            }' || echo "MCP server not available"
